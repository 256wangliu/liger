---
title: "Walkthrough - Integrating scRNA-seq and scATAC-seq Data"
author: "Joshua Sodicoff"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '/nfs/turbo/umms-welchjd/sodicoff/pbmc_integration')
```
This walkthrough will demonstrate Liger's ability to analyze and integrate multi-omics data. We will be using scRNA-seq and scATAC-seq datasets of peripheral blood mononuclear cells (PBMCs) provided by 10X and generated by their `cellranger count` pipeline. We will again show many of the same functions for analysis and alignment and discuss differences in interpretation for multi-omics data.

## Preparation

We will demonstrate the methods that can be used to make the digital gene expression (DGE) matrices, starting from the `fragments.tsv` file output by 10X. Alternatively, the expression matrices used and all other inputs used are in the `vignettes/pbmc_integration.zip` directory and directions to load them directly are below.

```{r shortcut, results='hide', message=F, warning=F, eval = F}
pbmc.atac <- readRDS('pbmc.atac.expression.mat.RDS')
pbmc.rna <- readRDS('pbmc.rna.expression.mat.RDS')
```

### scATAC-seq

We sort the fragments output by `cellranger` by barcode and use BEDOPS' `bedmap` tool to make a list of cells that overlap each gene and promoter.

```{r bedmap, results='hide', message=F, warning=F, eval = F}
system(sort -k4,4 atac_fragments.tsv > atac_fragments.sort.bed)
system(bedmap --delim "\t" --echo --echo-map-id hg19_genes.bed atac_fragments.sort.bed > atac_genes_bc.bed)
system(bedmap --delim "\t" --echo --echo-map-id hg19_promoters.bed atac_fragments.sort.bed > atac_promoters_bc.bed)
```

We then import the output files into R. Note that we use the `as.is` parameter in `read.table` to supress the conversion of character columns like gene symbol to factors. Using Liger's `makeFeatureMatrix` utility, we make DGEs for both the gene and promoter counts. Finally, we sort the DGEs rows by feature and add them together.

```{r make.feature.mats, results='hide', message=F, warning=F, eval = F}
library(liger)

genes.bc <- read.table(file = "atac_genes_bc.bed", sep = "\t", as.is = c(4,7), header = FALSE)
promoters.bc <- read.table(file = "atac_promoters_bc.bed", sep = "\t", as.is = c(4,7), header = FALSE)
#The makeFeatureMatrix function requires the barcodes from the filtered_peak_bc_matrix directory as a vector
barcodes <- as.vector(read.table(file = "rna/filtered_peak_bc_matrix/barcodes.tsv", sep = "\t", as.is = c(1), header = FALSE)[,1])

gene.counts <- makeFeatureMatrix(genes.bc, barcodes)
promoter.counts <- makeFeatureMatrix(promoters.bc, barcodes)

gene.counts <- gene.counts[order(rownames(gene.counts)),]
promoter.counts <- promoter.counts[order(rownames(promoter.counts)),]
pbmc.atac <- gene.counts + promoter.counts
```

### scRNA-seq

Liger's `read10X` function can be used to convert `cellranger count` output files for gene expression into DGEs.

```{r rna_seq, results='hide', message=F, warning=F, eval = F}
library(liger)

sample.dir = 'rna'
sample.name = 'pbmc.rna'

pbmc.rna <- read10X(sample.dirs = list(sample.dir), sample.names = list(sample.name))
```

Finally, we can make a list of of the DGEs and pass this as parameter to the `createLiger` function to create a Liger object.

```{r createLiger, results='hide', message=F, warning=F, eval = F}
pbmc.data = list(atac=pbmc.atac, rna=pbmc.rna)
int.pbmc <- createLiger(pbmc.data)
```

## Data preprocessing
The algorithm takes a list of two or more digital gene expression (DGE) matrices as input. Genes should be in rows and cells in columns. Before running the factorization, we need to normalize the data to account for different numbers of UMIs per cell with `normalize`, select variable genes with `selectGenes`, and scale the data with `scaleNotCenter`. Note that we do not center the data because nonnegative matrix factorization accepts only positive values.

The `selectGenes` function performs variable gene selection on each of the datasets separately, then takes the union of the result. The most variable genes are selected by comparing the variance of each gene's expression to its mean expression and keeping those with var/mean ratio above a certain threshold. Because scATAC-seq data cannot be assumed to follow the same statistical distribution as scRNA-seq data and the `selectGenes` function was written primarily scRNA-seq in mind, we should use another method to find the most variably expressed genes. A variety of applications for the determination of variably expressed genes exist, but for the purposes of this walkthrough, we can create a new Liger object with only the scRNA-seq data and pass the intersection of its variable genes and the genes in the scATAC-seq data to the object.

```{r preprocessing, results='hide', message=F, warning=F, eval = F}
int.pbmc <- normalize(int.pbmc)

#Preprocessing for the liger object using only the scRNA-seq data
ligex.rna <- createLiger(list(rna = pbmc.rna))
ligex.rna <- normalize(ligex.rna)
ligex.rna <- selectGenes(ligex.rna)
int.pbmc@var.genes = intersect(ligex.rna@var.genes, rownames(pbmc.atac))
rm(ligex.rna)

int.pbmc <- scaleNotCenter(int.pbmc)
```

###Factorization
Next we perform integrative non-negative matrix factorization in order to identify shared and distinct metagenes across the datasets and the corresponding factor/metagene loadings for each cell. The most important parameters in the factorization are `k` (the number of factors) and `lambda` (the penalty parameter which limits the dataset-specific component of the factorization). The default value of `lambda=5.0` usually provides reasonable results for most analyses, although the `suggestLambda` function can be used to determine a more appropriate `lambda` value for the desired level of dataset alignment. 

To determine the appropriate number of factors to use, we can use the `suggestK` function which plots median K-L divergence from the uniform distribution in the factor loadings as a function of `k`. We want to look for the section of the plot where this metric stops increasing as sharply (the "elbow" of the plot). In general, we should expect a positive correlation between the number of subgroups we expect to find in the analysis and the appropriate number of factors to use. Since the `suggestK` function can take more than 10 minutes to run, it can sometimes be useful to run a quick preliminary analysis with `k=20` to get an idea of whether a much higher number of factors is needed. Additionally, both `suggestLambda` and `suggestK` can take advantage of parallel processing to increase their speed.

``` {r selection, eval=F}
lambda.suggest <- suggestLambda(int.pbmc, num.cores = 5)
k.suggest <- suggestK(int.pbmc, num.cores = 5, return.results = T)
```

For this analysis, we select `k = 30` and `lambda = 5.0`. We'll also run `optimizeALS` with `nrep = 5` because the iNMF objective function is non-convex, meaning that there may be several locally optimal solutions.

```{r factorization, results='hide', eval=F}
int.pbmc <- optimizeALS(int.pbmc, k=30, thresh = 5e-5, nrep = 5)
```

After the factorization, we still need to quantile align the factor loadings across the datasets. Notice that if we plot a t-SNE representation of the factor loadings, the data still cluster mainly by dataset. 

```{r unaligned, eval=F}
int.pbmc <- runTSNE(int.pbmc, use.raw = T)
p1 <- plotByDatasetAndCluster(int.pbmc, return.plots = T)
print(p1[[1]])
```
`pbmc_fig1`

To better integrate the datasets, we perform a quantile alignment step. This process first identifies similarly loading cells across datasets by building a similarity graph based on shared factor neighborhoods. Using Louvain community detection, we then identify clusters shared across datasets, and align quantiles within each cluster and factor. The key parameters in this step are the `resolution` (increasing this increases the number of communities detected) and `knn_k` (the number of dataset neighbors used in generating the shared factor neighborhood). In general, lowering `knn_k` will allow for more fine-grained identification of smaller groups with shared factor neighborhoods. 

```{r aligned, results='hide', eval=F}
int.pbmc <- quantileAlignSNF(int.pbmc, knn_k = 15)
```

###Visualization 

Now we can visualize the integrated data, and determine identities of the detected clusters.

```{r visualize.aligned, fig.width=6, fig.height=4.5, eval=F}
int.pbmc <- runTSNE(int.pbmc)
p2 <- plotByDatasetAndCluster(int.pbmc, return.plots = T) 

print(p2[[1]])
```
`pbmc_fig2`

Next, let's visualize which factors load the most highly for each cluster. The `plotClusterFactors` function outputs a heatmap of factors by clusters, with color determined by the sum of row-normalized factor loadings.

```{r visualize.heatmap, fig.width=6, fig.height=4.5, eval=F}
plotClusterFactors(int.pbmc)
```
`pbmc_fig4`

From this plot, we can see that cluster 9 highly loads factor 3. Let's use Liger's other tools to look further into this. Using the `getFactorMarkers` function, we can get a dataframe of the genes that load most heavily on each factor.

```{r getFactorMarkers, results='hide', fig.width=5, fig.height=6, eval=F}
markers <- getFactorMarkers(int.pbmc, num.genes = 20)
head(markers$shared[markers$shared$factor_num == 9, ])
```

I ran the top 20 markers for factor 9 through [ShinyGo](http://bioinformatics.sdstate.edu/go/), a simple online tool for gene ontology enrichment analysis.

```{r go.enrichment, echo = F, eval=F}
go.output <- readRDS('go_enrichment.RDS')
print(go.output[1:10,])
```

We see that the highest ranked terms correspond with immune cell activation and proliferation, specifically B lymphocyte specific terms. In this case, the use of gene ontology enrichment aided us in narrowing down the cell type for classification.

For a more graphical output, we can also use the `plotWordClouds` function.

```{r word.clouds, fig.width=5, fig.height=6, eval=F}
word_clouds <- plotWordClouds(int.pbmc, num.genes = 10, do.spec.plot = F, return.plots = T)
print(word_clouds[[9]])
```